
@book{aitameurAbstractStateMachines2014,
  title = {Abstract {{State Machines}}, {{Alloy}}, {{B}}, {{TLA}}, {{VDM}}, and {{Z}}: 4th {{International Conference}}, {{ABZ}} 2014, {{Toulouse}}, {{France}}, {{June}} 2-6, 2014. {{Proceedings}}},
  shorttitle = {Abstract {{State Machines}}, {{Alloy}}, {{B}}, {{TLA}}, {{VDM}}, and {{Z}}},
  editor = {Ait Ameur, Yamine and Schewe, Klaus-Dieter},
  date = {2014},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {8477},
  publisher = {{Springer Berlin Heidelberg}},
  location = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-662-43652-3},
  url = {http://link.springer.com/10.1007/978-3-662-43652-3},
  urldate = {2022-09-05},
  editorb = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Kobsa, Alfred and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Terzopoulos, Demetri and Tygar, Doug and Weikum, Gerhard},
  editorbtype = {redactor},
  isbn = {978-3-662-43651-6 978-3-662-43652-3},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\CEJHIM5B\\Ait Ameur and Schewe - 2014 - Abstract State Machines, Alloy, B, TLA, VDM, and Z.pdf}
}

@article{avizienisBasicConceptsTaxonomy2004,
  title = {Basic Concepts and Taxonomy of Dependable and Secure Computing},
  author = {Avizienis, A. and Laprie, J.-C. and Randell, B. and Landwehr, C.},
  date = {2004-01},
  journaltitle = {IEEE Transactions on Dependable and Secure Computing},
  shortjournal = {IEEE Trans.Dependable and Secure Comput.},
  volume = {1},
  number = {1},
  pages = {11--33},
  issn = {1545-5971},
  doi = {10.1109/TDSC.2004.2},
  url = {http://ieeexplore.ieee.org/document/1335465/},
  urldate = {2022-07-24},
  abstract = {This paper gives the main definitions relating to dependability, a generic concept including as special case such attributes as reliability, availability, safety, integrity, maintainability, etc. Security brings in concerns for confidentiality, in addition to availability and integrity. Basic definitions are given first. They are then commented upon, and supplemented by additional definitions, which address the threats to dependability and security (faults, errors, failures), their attributes, and the means for their achievement (fault prevention, fault tolerance, fault removal, fault forecasting). The aim is to explicate a set of general concepts, of relevance across a wide range of situations and, therefore, helping communication and cooperation among a number of scientific and technical communities, including ones that are concentrating on particular types of system, of system failures, or of causes of system failures.},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\SGB8RUGS\\Avizienis et al. - 2004 - Basic concepts and taxonomy of dependable and secu.pdf}
}

@incollection{baldorMonitoringDenseTimeContinuousSemantics2013,
  title = {Monitoring {{Dense-Time}}, {{Continuous-Semantics}}, {{Metric Temporal Logic}}},
  booktitle = {Runtime {{Verification}}},
  author = {Baldor, Kevin and Niu, Jianwei},
  editor = {Qadeer, Shaz and Tasiran, Serdar},
  date = {2013},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {7687},
  pages = {245--259},
  publisher = {{Springer Berlin Heidelberg}},
  location = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-35632-2_24},
  url = {http://link.springer.com/10.1007/978-3-642-35632-2_24},
  urldate = {2022-07-23},
  abstract = {The continuous semantics and dense time model most closely model the intuitive meaning of properties specified in metric temporal logic (mtl). To date, monitoring algorithms for mtl with dense time and continuous semantics lacked the simplicity the standard algorithms for discrete time and pointwise semantics. In this paper, we present a novel, transition-based, representation of dense-time boolean signals that lends itself to the construction of efficient monitors for safety properties defined in metric temporal logic with continuous semantics. Using this representation, we present a simple lookup-table-based algorithm for monitoring formulas consisting of arbitrarily nested mtl operators. We examine computational and space complexity of this monitoring algorithm for the past-only, restricted-future, and unrestricted-future temporal operators.},
  editorb = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard},
  editorbtype = {redactor},
  isbn = {978-3-642-35631-5 978-3-642-35632-2},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\KV4RUC5A\\Baldor and Niu - 2013 - Monitoring Dense-Time, Continuous-Semantics, Metri.pdf}
}

@article{baralGoalSpecificationUsing,
  title = {Goal Specification Using Temporal Logic in Presence of Non-Deterministic Actions},
  author = {Baral, Chitta and Barry, Matt},
  pages = {6},
  abstract = {In this paper we show that despite a past claim goals such as ‘try your best to make p true’ in presence of non-deterministic actions can be expressed in the framework of branching time temporal logic. We analyze the A and E operators in CTL∗ and point out why it was thought that the above mentioned goal can not be expressed using CTL∗. We then introduce the operators Aπ and Eπ (and present a temporal logic π-CTL∗) which take into account the policy being followed by the agent and show that using these operators we can indeed specify the above mentioned goal.},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\DUM5IV5W\\Baral and Barry - Goal speciﬁcation using temporal logic in presence.pdf}
}

@online{BaremetalMultiCoreSystems,
  title = {{{F}}´ {{On Baremetal}} and {{Multi-Core Systems}}},
  url = {https://nasa.github.io/fprime/v3.1.0/UsersGuide/dev/baremetal-multicore.html},
  urldate = {2022-08-10},
  abstract = {Flight Software \& Embedded Systems Framework},
  langid = {american},
  organization = {{F´}},
  file = {C\:\\Users\\User\\Zotero\\storage\\3UQBC75M\\baremetal-multicore.html}
}

@incollection{bartocciIntroductionRuntimeVerification2018,
  title = {Introduction to {{Runtime Verification}}},
  booktitle = {Lectures on {{Runtime Verification}}: {{Introductory}} and {{Advanced Topics}}},
  author = {Bartocci, Ezio and Falcone, Yliès and Francalanza, Adrian and Reger, Giles},
  editor = {Bartocci, Ezio and Falcone, Yliès},
  date = {2018},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {1--33},
  publisher = {{Springer International Publishing}},
  location = {{Cham}},
  doi = {10.1007/978-3-319-75632-5_1},
  url = {https://doi.org/10.1007/978-3-319-75632-5_1},
  urldate = {2022-09-06},
  abstract = {The aim of this chapter is to act as a primer for those wanting to learn about Runtime Verification (RV). We start by providing an overview of the main specification languages used for RV. We then introduce the standard terminology necessary to describe the monitoring problem, covering the pragmatic issues of monitoring and instrumentation, and discussing extensively the monitorability problem.},
  isbn = {978-3-319-75632-5},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\VE235TUN\\Bartocci et al. - 2018 - Introduction to Runtime Verification.pdf}
}

@book{bartocciLecturesRuntimeVerification2018,
  title = {Lectures on {{Runtime Verification}}},
  editor = {Bartocci, Ezio and Falcone, Yliès},
  date = {2018},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {10457},
  publisher = {{Springer International Publishing}},
  location = {{Cham}},
  doi = {10.1007/978-3-319-75632-5},
  url = {http://link.springer.com/10.1007/978-3-319-75632-5},
  urldate = {2022-09-06},
  isbn = {978-3-319-75631-8 978-3-319-75632-5},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\6MBRBXLQ\\Bartocci and Falcone - 2018 - Lectures on Runtime Verification.pdf}
}

@article{basinAlgorithmsMonitoringRealtime,
  title = {Algorithms for {{Monitoring Real-time Properties}}},
  author = {Basin, David and Klaedtke, Felix},
  pages = {32},
  abstract = {Real-time logics are popular specification languages for reasoning about systems intended to meet timing constraints. Numerous formalisms have been proposed with different underlying time models that can be characterized along two dimensions: dense versus discrete time and point-based versus interval-based. We present monitoring algorithms for the past-only fragment of metric temporal logics that differ along these two dimensions, analyze their complexity, and compare them on a class of formulas for which the point-based and the interval-based settings coincide. Our comparison reveals similarities and differences between the monitoring algorithms and highlights key concepts underlying our and prior monitoring algorithms. For example, point-based algorithms are conceptually simpler and more efficient than interval-based ones as they are invoked only at time points occurring in the monitored trace and their reasoning is limited to just those time points.},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\J92E7YCS\\Basin and Klaedtke - Algorithms for Monitoring Real-time Properties.pdf}
}

@article{bocchinoPrimeOpenSourceFrameworka,
  title = {F {{Prime}}: {{An Open-Source Framework}} for {{Small-Scale Flight Software Systems}}},
  author = {Bocchino, Robert and Canham, Timothy and Watney, Garth and Reder, Leonard and Levison, Jeffrey},
  pages = {19},
  abstract = {Developing flight software for small-scale missions such as CubeSats and SmallSats is challenging. These missions typically have ambitious goals, modest budgets, and tight schedules. To meet these challenges, a good flight software framework is essential. Frameworks can provide an architecture, infrastructure, tools, and reusable software components, all of which can help developers deliver their code on time and on budget.},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\L8RI9VCR\\Bocchino et al. - F Prime An Open-Source Framework for Small-Scale .pdf}
}

@online{caldwellSmallSpacecraftAvionics2021,
  type = {Text},
  title = {8.0 Small Spacecraft Avionics},
  author = {Caldwell, Sonja},
  date = {2021-10-16T14:11-04:00},
  url = {http://www.nasa.gov/smallsat-institute/sst-soa/small-spacecraft-avionics},
  urldate = {2022-07-28},
  abstract = {NASA.gov brings you the latest images, videos and news from America's space agency. Get the latest updates on NASA missions, watch NASA TV live, and learn about our quest to reveal the unknown and benefit all humankind.},
  langid = {und},
  organization = {{NASA}},
  file = {C\:\\Users\\User\\Zotero\\storage\\HEXQ95SD\\small-spacecraft-avionics.html}
}

@online{CodeStyleGuidelines,
  title = {Code and {{Style Guidelines}}},
  url = {https://nasa.github.io/fprime/UsersGuide/dev/code-style.html},
  urldate = {2022-07-24},
  abstract = {Flight Software \& Embedded Systems Framework},
  langid = {american},
  organization = {{F´}},
  file = {C\:\\Users\\User\\Zotero\\storage\\JEEIMJRG\\code-style.html}
}

@online{Features,
  title = {{{F}}´ {{Features}}},
  url = {https://nasa.github.io/fprime/features.html},
  urldate = {2022-07-23},
  abstract = {Flight Software \& Embedded Systems Framework},
  langid = {american},
  organization = {{F´}},
  file = {C\:\\Users\\User\\Zotero\\storage\\355KIUWR\\features.html}
}

@online{FlightSoftwareDocumentation,
  title = {{{F}}´ {{Flight Software}} - {{C}}/{{C}}++ {{Documentation}}: {{Main Page}}},
  url = {https://nasa.github.io/fprime/UsersGuide/api/c++/html/index.html},
  urldate = {2022-08-08},
  file = {C\:\\Users\\User\\Zotero\\storage\\AK9N7TNT\\index.html}
}

@book{gammaDesignPatternsElements1994,
  title = {Design {{Patterns}}: {{Elements}} of {{Reusable Object-Oriented Software}}},
  shorttitle = {{{GoF}}},
  author = {Gamma, Erich and Helm, Richard and Johnson, Ralph and Vlissided, John},
  date = {1994},
  publisher = {{AddisonWesley Professional}},
  isbn = {978-0-201-63361-0}
}

@online{GDSDashboardComponent,
  title = {{{GDS Dashboard Component Reference}}},
  url = {https://nasa.github.io/fprime/v3.1.0/UsersGuide/dev/gds-dashboard-reference.html},
  urldate = {2022-08-10},
  abstract = {Flight Software \& Embedded Systems Framework},
  langid = {american},
  organization = {{F´}},
  file = {C\:\\Users\\User\\Zotero\\storage\\N2V6ITFA\\gds-dashboard-reference.html}
}

@inproceedings{goldbergRuntimeVerificationAutonomous2005,
  title = {Runtime Verification for Autonomous Spacecraft Software},
  booktitle = {2005 {{IEEE Aerospace Conference}}},
  author = {Goldberg, A. and Havelund, K. and McGann, C.},
  date = {2005},
  pages = {507--516},
  publisher = {{IEEE}},
  location = {{Big Sky, MT, USA}},
  doi = {10.1109/AERO.2005.1559341},
  url = {http://ieeexplore.ieee.org/document/1559341/},
  urldate = {2022-07-24},
  eventtitle = {2005 {{IEEE Aerospace Conference}}},
  isbn = {978-0-7803-8870-3},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\HVU2ND5Z\\Goldberg et al. - 2005 - Runtime verification for autonomous spacecraft sof.pdf}
}

@incollection{gorankoTemporalLogic2022,
  title = {Temporal {{Logic}}},
  booktitle = {The {{Stanford Encyclopedia}} of {{Philosophy}}},
  author = {Goranko, Valentin and Rumberg, Antje},
  editor = {Zalta, Edward N.},
  date = {2022},
  edition = {Summer 2022},
  publisher = {{Metaphysics Research Lab, Stanford University}},
  url = {https://plato.stanford.edu/archives/sum2022/entries/logic-temporal/},
  urldate = {2022-08-06},
  abstract = {The term Temporal Logic has been broadly used to cover allapproaches to reasoning about time and temporal information, as well as their formal representation, within a logical framework, and also more narrowly to refer specifically to the modal-logic type of approach introduced around 1960 by Arthur Prior under the name Tense Logic and subsequently developed further by many logicians and computerscientists. Applications of Temporal Logic include its use as aformalism for clarifying philosophical issues about time, as aframework within which to define the semantics of temporal expressionsin natural language, as a language for encoding temporal knowledge inartificial intelligence, and as a tool for specification, formalanalysis, and verification of the executions of computer programs andsystems., Here we provide a broadly representative, yet concise and inevitablyincomplete, overview of the rich variety of temporal models and logicsintroduced and studied over the past 50 years.},
  keywords = {artificial intelligence: logic and,Diodorus Cronus,frame problem,future contingents,identity: over time,logic: action,logic: combining,logic: free,logic: hybrid,logic: intensional,logic: modal,McTaggart; John M. E.,Ockham [Occam]; William,Prior; Arthur,temporal parts,tense and aspect,time},
  file = {C\:\\Users\\User\\Zotero\\storage\\YIQG9MU9\\logic-temporal.html}
}

@incollection{gorankoTemporalLogic2022a,
  title = {Temporal {{Logic}}},
  booktitle = {The {{Stanford Encyclopedia}} of {{Philosophy}}},
  author = {Goranko, Valentin and Rumberg, Antje},
  editor = {Zalta, Edward N.},
  date = {2022},
  edition = {Summer 2022},
  publisher = {{Metaphysics Research Lab, Stanford University}},
  url = {https://plato.stanford.edu/archives/sum2022/entries/logic-temporal/},
  urldate = {2022-08-09},
  abstract = {The term Temporal Logic has been broadly used to cover allapproaches to reasoning about time and temporal information, as well as their formal representation, within a logical framework, and also more narrowly to refer specifically to the modal-logic type of approach introduced around 1960 by Arthur Prior under the name Tense Logic and subsequently developed further by many logicians and computerscientists. Applications of Temporal Logic include its use as aformalism for clarifying philosophical issues about time, as aframework within which to define the semantics of temporal expressionsin natural language, as a language for encoding temporal knowledge inartificial intelligence, and as a tool for specification, formalanalysis, and verification of the executions of computer programs andsystems., Here we provide a broadly representative, yet concise and inevitablyincomplete, overview of the rich variety of temporal models and logicsintroduced and studied over the past 50 years.},
  keywords = {artificial intelligence: logic and,Diodorus Cronus,frame problem,future contingents,identity: over time,logic: action,logic: combining,logic: free,logic: hybrid,logic: intensional,logic: modal,McTaggart; John M. E.,Ockham [Occam]; William,Prior; Arthur,temporal parts,tense and aspect,time},
  file = {C\:\\Users\\User\\Zotero\\storage\\HS76SHXL\\logic-temporal.html}
}

@article{havelundFirstorderTemporalLogic2020,
  title = {First-Order Temporal Logic Monitoring with {{BDDs}}},
  author = {Havelund, Klaus and Peled, Doron and Ulus, Dogan},
  date = {2020-12-01},
  journaltitle = {Formal Methods in System Design},
  shortjournal = {Form Methods Syst Des},
  volume = {56},
  number = {1},
  pages = {1--21},
  issn = {1572-8102},
  doi = {10.1007/s10703-018-00327-4},
  url = {https://doi.org/10.1007/s10703-018-00327-4},
  urldate = {2022-07-23},
  abstract = {Runtime verification is aimed at analyzing execution traces stemming from a running program or system. The traditional purpose is to detect the lack of conformance with respect to a formal specification. Numerous efforts in the field have focused on monitoring parametric specifications, where events carry data, and formulas can refer to such. Since a monitor for such specifications has to store observed data, the challenge is to have an efficient representation and manipulation of Boolean operators, quantification, and lookup of data. The fundamental problem is that the actual values of the data are not necessarily bounded or provided in advance. In this work we explore the use of binary decision diagrams for representing observed data. Our experiments show a substantial improvement in performance compared to related work.},
  langid = {english},
  keywords = {BDDs,Data,Past time temporal logic},
  file = {C\:\\Users\\User\\Zotero\\storage\\D47F25PK\\Havelund et al. - 2020 - First-order temporal logic monitoring with BDDs.pdf}
}

@incollection{hertzIntegratingRuntimeVerification2021,
  title = {Integrating {{Runtime Verification}} into a {{Sounding Rocket Control System}}},
  booktitle = {{{NASA Formal Methods}}},
  author = {Hertz, Benjamin and Luppen, Zachary and Rozier, Kristin Yvonne},
  editor = {Dutle, Aaron and Moscato, Mariano M. and Titolo, Laura and Muñoz, César A. and Perez, Ivan},
  date = {2021},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {12673},
  pages = {151--159},
  publisher = {{Springer International Publishing}},
  location = {{Cham}},
  doi = {10.1007/978-3-030-76384-8_10},
  url = {https://link.springer.com/10.1007/978-3-030-76384-8_10},
  urldate = {2022-07-24},
  abstract = {An actuation fault in the aerobraking control system (ACS) took down Iowa State’s Nova Somnium rocket during the 2019 Spaceport America Cup competition, prematurely ending the team’s participation. The ACS engaged incorrectly before motor burnout, altering the rocket’s trajectory and leading to a dangerous crash. The ability to detect this fault in real time on-board the ACS’s Arduino microcontroller would have prevented an uncontrolled landing and rapid unscheduled disassembly, which posed a major safety threat and ended a year’s worth of effort by the 50-student team. Runtime verification (RV) specializes in efficiently catching this type of scenario; the R2U2 RV engine uniquely fits in the project’s resource constraints. We design specifications to detect ACS faults and trigger the appropriate mitigations. We discuss specification development, validation, coverage, and robustness against false positives. Experimental evaluation on the real, recorded flight data demonstrates that running R2U2 on the Nova Somnium ACS would have prevented this accident from occurring. We generalize our results and outline our plans for integrating runtime verification into future sounding rockets.},
  isbn = {978-3-030-76383-1 978-3-030-76384-8},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\Z8TZACCQ\\Hertz et al. - 2021 - Integrating Runtime Verification into a Sounding R.pdf}
}

@incollection{hertzIntegratingRuntimeVerification2021a,
  title = {Integrating {{Runtime Verification}} into a {{Sounding Rocket Control System}}},
  booktitle = {{{NASA Formal Methods}}},
  author = {Hertz, Benjamin and Luppen, Zachary and Rozier, Kristin Yvonne},
  editor = {Dutle, Aaron and Moscato, Mariano M. and Titolo, Laura and Muñoz, César A. and Perez, Ivan},
  date = {2021},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {12673},
  pages = {151--159},
  publisher = {{Springer International Publishing}},
  location = {{Cham}},
  doi = {10.1007/978-3-030-76384-8_10},
  url = {https://link.springer.com/10.1007/978-3-030-76384-8_10},
  urldate = {2022-07-27},
  abstract = {An actuation fault in the aerobraking control system (ACS) took down Iowa State’s Nova Somnium rocket during the 2019 Spaceport America Cup competition, prematurely ending the team’s participation. The ACS engaged incorrectly before motor burnout, altering the rocket’s trajectory and leading to a dangerous crash. The ability to detect this fault in real time on-board the ACS’s Arduino microcontroller would have prevented an uncontrolled landing and rapid unscheduled disassembly, which posed a major safety threat and ended a year’s worth of effort by the 50-student team. Runtime verification (RV) specializes in efficiently catching this type of scenario; the R2U2 RV engine uniquely fits in the project’s resource constraints. We design specifications to detect ACS faults and trigger the appropriate mitigations. We discuss specification development, validation, coverage, and robustness against false positives. Experimental evaluation on the real, recorded flight data demonstrates that running R2U2 on the Nova Somnium ACS would have prevented this accident from occurring. We generalize our results and outline our plans for integrating runtime verification into future sounding rockets.},
  isbn = {978-3-030-76383-1 978-3-030-76384-8},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\4IDZ5D5S\\Hertz et al. - 2021 - Integrating Runtime Verification into a Sounding R.pdf}
}

@online{HomeFprimecommunityFpp,
  title = {Home · Fprime-Community/Fpp {{Wiki}}},
  url = {https://github.com/fprime-community/fpp},
  urldate = {2022-07-23},
  abstract = {F Prime Prime: A modeling language for F Prime. Contribute to fprime-community/fpp development by creating an account on GitHub.},
  langid = {english},
  organization = {{GitHub}},
  file = {C\:\\Users\\User\\Zotero\\storage\\DYHUHMBG\\wiki.html}
}

@online{https://www.jpl.nasa.govMeetOpenSourceSoftware,
  title = {Meet the {{Open-Source Software Powering NASA}}’s {{Ingenuity Mars Helicopter}}},
  author = {{https://www.jpl.nasa.gov}},
  url = {https://www.jpl.nasa.gov/news/meet-the-open-source-software-powering-nasas-ingenuity-mars-helicopter},
  urldate = {2022-07-23},
  abstract = {Created at NASA’s JPL, the open-source flight software called F Prime isn’t just powering humanity’s first interplanetary helicopter; it’s also powering inspiration at multiple universities.},
  langid = {american},
  organization = {{NASA Jet Propulsion Laboratory (JPL)}},
  file = {C\:\\Users\\User\\Zotero\\storage\\5EEN8YJM\\meet-the-open-source-software-powering-nasas-ingenuity-mars-helicopter.html}
}

@article{jrFPPModelingLanguage,
  title = {{{FPP}}: {{A Modeling Language}} for {{F Prime}}},
  author = {Jr, Robert L Bocchino and Levison, Jeffrey W and Starch, Michael D},
  pages = {15},
  abstract = {We present F Prime Prime (FPP), a new open-source modeling language for F Prime. F Prime is an open-source flight software framework developed at JPL and deployed, among other places, on the Mars helicopter Ingenuity. FPP provides a convenient way to model the architectural elements of an F Prime application, e.g., components, ports, and their connections. It has a succinct and readable syntax, a welldefined semantics, and robust error checking and reporting. The FPP tool suite, written in Scala, analyzes FPP models, reports errors, and translates correct FPP models to a combination of XML and C++. Existing F Prime tools translate the XML to a partial implementation in C++, to be completed by the developers. The model elements have clean interfaces and are highly reusable. An accompanying visualization tool constructs diagrams of components and connections that FSW developers can use to understand and communicate their designs, for example at reviews. We discuss the design and implementation of FPP and the integration of FPP into F Prime. We also discuss our experience using FPP to construct F Prime models. Finally, we discuss our plans for future work, including improved code generation, improved visualization, and more advanced analysis capabilities.},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\X2WNU3IP\\Jr et al. - FPP A Modeling Language for F Prime.pdf}
}

@article{katoenComplexityConsiderations,
  title = {5 {{Complexity Considerations}}},
  author = {Katoen, Joost-Pieter},
  pages = {11},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\387EPQY5\\Katoen - 5 Complexity Considerations.pdf}
}

@software{lohmannJSONModern2022,
  title = {{{JSON}} for {{Modern C}}++},
  author = {Lohmann, Niels},
  date = {2022-08},
  origdate = {2013-07-04T08:47:49Z},
  url = {https://github.com/nlohmann},
  urldate = {2022-09-07},
  abstract = {JSON for Modern C++},
  version = {3.11.2}
}

@online{MagicDrawCATIADassault,
  title = {{{MagicDraw}} - {{CATIA}} - {{Dassault Systèmes}}®},
  url = {https://www.3ds.com/products-services/catia/products/no-magic/magicdraw/},
  urldate = {2022-07-28},
  abstract = {MagicDraw - No Magic is one of the most respected providers of standards-compliant modeling, simulation and analysis solutions in the industry.},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\BGTYFBXM\\magicdraw.html}
}

@online{ManEquationRocket,
  title = {A {{Man}} – and an Equation – {{Rocket Science}}},
  url = {https://blogs.esa.int/rocketscience/2012/10/14/a-man-and-an-equation/},
  urldate = {2022-09-06},
  abstract = {News from the edge of gravity},
  langid = {american},
  file = {C\:\\Users\\User\\Zotero\\storage\\YDHA6E9M\\a-man-and-an-equation.html}
}

@software{martindaleFPPTools2022,
  title = {{{FPPTools}}},
  author = {Martindale, Daniel},
  date = {2022-06-06T14:03:42Z},
  origdate = {2022-04-22T02:47:13Z},
  url = {https://github.com/phxe/fpptools},
  urldate = {2022-07-24},
  abstract = {F Prime Prime Language Support for Visual Studio Code}
}

@online{MathComponentTutorial,
  title = {F’ {{Math Component Tutorial}}},
  url = {https://nasa.github.io/fprime/Tutorials/MathComponent/Tutorial.html},
  urldate = {2022-07-24},
  abstract = {Flight Software \& Embedded Systems Framework},
  langid = {american},
  organization = {{F´}},
  file = {C\:\\Users\\User\\Zotero\\storage\\KHE8I78Z\\Tutorial.html}
}

@article{meierComplexitySatisfiabilityFragments2008,
  title = {The {{Complexity}} of {{Satisfiability}} for {{Fragments}} of {{CTL}} and {{CTL}}⋆},
  author = {Meier, Arne and Mundhenk, Martin and Thomas, Michael and Vollmer, Heribert},
  date = {2008-12},
  journaltitle = {Electronic Notes in Theoretical Computer Science},
  shortjournal = {Electronic Notes in Theoretical Computer Science},
  volume = {223},
  pages = {201--213},
  issn = {15710661},
  doi = {10.1016/j.entcs.2008.12.040},
  url = {https://linkinghub.elsevier.com/retrieve/pii/S1571066108005033},
  urldate = {2022-08-09},
  abstract = {The satisfiability problems for CTL and CTL are known to be EXPTIME-complete, resp. 2EXPTIMEcomplete (Fischer and Ladner (1979), Vardi and Stockmeyer (1985)). For fragments that use less temporal or propositional operators, the complexity may decrease. This paper undertakes a systematic study of satisfiability for CTL- and CTL -formulae over restricted sets of propositional and temporal operators. We show that restricting the temporal operators yields satisfiability problems complete for 2EXPTIME, EXPTIME, PSPACE, and NP. Restricting the propositional operators either does not change the complexity (as determined by the temporal operators), or yields very low complexity like NC1, TC0, or NLOGTIME.},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\RU8IXZKR\\Meier et al. - 2008 - The Complexity of Satisfiability for Fragments of .pdf}
}

@article{moosbruggerR2U2MonitoringDiagnosis2017,
  title = {{{R2U2}}: Monitoring and Diagnosis of Security Threats for Unmanned Aerial Systems},
  shorttitle = {{{R2U2}}},
  author = {Moosbrugger, Patrick and Rozier, Kristin Y. and Schumann, Johann},
  date = {2017-08},
  journaltitle = {Formal Methods in System Design},
  shortjournal = {Form Methods Syst Des},
  volume = {51},
  number = {1},
  pages = {31--61},
  issn = {0925-9856, 1572-8102},
  doi = {10.1007/s10703-017-0275-x},
  url = {http://link.springer.com/10.1007/s10703-017-0275-x},
  urldate = {2022-07-24},
  abstract = {We present R2U2, a novel framework for runtime monitoring of security properties and diagnosing of security threats on-board Unmanned Aerial Systems (UAS). R2U2, implemented in FPGA hardware, is a real-time, Realizable, Responsive, Unobtrusive Unit for runtime system analysis, now including security threat detection. R2U2 is designed to continuously monitor inputs from on-board components such as the GPS, the ground control station, other sensor readings, actuator outputs, and flight software status. By simultaneously monitoring and performing statistical reasoning, attack patterns and post-attack discrepancies in the UAS behavior can be detected. R2U2 uses runtime observer pairs for Linear and Metric Temporal Logics for property monitoring and Bayesian networks for diagnosis of system health during runtime. We discuss the design and implementation that now enables R2U2 to handle security threats and present simulation results of several attack scenarios on the NASA DragonEye UAS.},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\JGFVE5U5\\Moosbrugger et al. - 2017 - R2U2 monitoring and diagnosis of security threats.pdf}
}

@online{MoreCompleteIntroduction,
  title = {A {{More Complete Introduction To F}}´},
  url = {https://nasa.github.io/fprime/UsersGuide/user/full-intro.html},
  urldate = {2022-07-23},
  abstract = {Flight Software \& Embedded Systems Framework},
  langid = {american},
  organization = {{F´}},
  file = {C\:\\Users\\User\\Zotero\\storage\\K73FIT3I\\full-intro.html}
}

@online{NASAMarsHelicopter,
  title = {{{NASA}}'s {{Mars}} Helicopter Has a Problem. {{This}} Clever Software Trick Could Fix It | {{ZDNet}}},
  url = {https://www.zdnet.com/article/nasas-ingenuity-mars-helicopter-has-a-problem-this-clever-software-trick-could-fix-it/},
  urldate = {2022-07-29},
  file = {C\:\\Users\\User\\Zotero\\storage\\VW6Y8HCL\\nasas-ingenuity-mars-helicopter-has-a-problem-this-clever-software-trick-could-fix-it.html}
}

@incollection{ohrstromFutureContingents2020,
  title = {Future {{Contingents}}},
  booktitle = {The {{Stanford Encyclopedia}} of {{Philosophy}}},
  author = {Øhrstrøm, Peter and Hasle, Per},
  editor = {Zalta, Edward N.},
  date = {2020},
  edition = {Summer 2020},
  publisher = {{Metaphysics Research Lab, Stanford University}},
  url = {https://plato.stanford.edu/archives/sum2020/entries/future-contingents/},
  urldate = {2022-08-09},
  abstract = {Future contingents are contingent statements about the future —such as future events, actions, states etc. To qualify as contingentthe predicted event, state, action or whatever is at stake mustneither be impossible nor inevitable. Statements such as “Mymother shall go to London” or “There will be a sea-battletomorrow” could serve as standard examples. What could be calledthe problem of future contingents concerns how to ascribe truth-valuesto such statements. If there are several possible decisions out ofwhich one is going to be made freely tomorrow, can there be a truthnow about which one will be made? If “yes”, on whatgrounds could something which is still open, nevertheless be truealready now? If “no”, can we in fact hold that alllogically exclusive possibilities must be untrue without denying thatone of the possible outcomes must turn out to be the chosen one?[1], In point of fact, “future contingents” could also refer tofuture contingent objects. A statement like “The first astronautto go to Mars will have a unique experience” could be analyzedas referring to an object not yet existing, supposing that one day inthe distant future some person will indeed travel to Mars, but thatperson has not yet been born. The notion of ‘future contingentobjects’ involves important philosophical questions, forinstance the issue of ethical obligations towards future generations,quantification over “future contingent objects” etc.However, this entry is confined to the study of future contingentstatements., The problem of future contingents is interwoven with a number ofissues in theology, philosophy, logic, semantics of natural language,computer science, and applied mathematics. The theological issue ofhow to reconcile the assumption of God’s foreknowledge with thefreedom and moral accountability of human beings has been a mainimpetus to the discussion and a major inspiration to the developmentof various logical models of time and future contingents. Thistheological issue is connected with the general philosophical questionof determinism versus indeterminism. Within logic, the relationbetween time and modality must be studied and various modelssatisfying various assumptions with respect to the structure of timemust be developed and investigated. The project of formal semanticsfor natural languages also has to address the problem of how toascribe a correct semantics to statements about the future. Finally,it should be mentioned that temporal logic has found a remarkableapplication in computer science and applied mathematics (see Hasle andØhrstrøm 2004)., In the present context the issue of future contingents will beapproached from the viewpoint of philosophical logic with dueconsideration to philosophical-theological origins.},
  keywords = {compatibilism,free will,free will: divine foreknowledge and,future contingents: medieval theories of,incompatibilism: (nondeterministic) theories of free will,incompatibilism: arguments for,logic: temporal,Prior; Arthur,prophecy},
  file = {C\:\\Users\\User\\Zotero\\storage\\7ZQ26JHM\\future-contingents.html}
}

@incollection{ouaknineRecentResultsMetric2008,
  title = {Some {{Recent Results}} in {{Metric Temporal Logic}}},
  booktitle = {Formal {{Modeling}} and {{Analysis}} of {{Timed Systems}}},
  author = {Ouaknine, Joël and Worrell, James},
  editor = {Cassez, Franck and Jard, Claude},
  date = {2008},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {5215},
  pages = {1--13},
  publisher = {{Springer Berlin Heidelberg}},
  location = {{Berlin, Heidelberg}},
  issn = {0302-9743, 1611-3349},
  doi = {10.1007/978-3-540-85778-5_1},
  url = {http://link.springer.com/10.1007/978-3-540-85778-5_1},
  urldate = {2022-07-23},
  abstract = {Metric Temporal Logic (MTL) is a widely-studied real-time extension of Linear Temporal Logic. In this paper we survey results about the complexity of the satisfiability and model checking problems for fragments of MTL with respect to different semantic models. We show that these fragments have widely differing complexities: from polynomial space to non-primitive recursive and even undecidable. However we show that the most commonly occurring real-time properties, such as invariance and bounded response, can be expressed in fragments of MTL for which model checking, if not satisfiability, can be decided in polynomial or exponential space.},
  isbn = {978-3-540-85777-8 978-3-540-85778-5},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\KJUT7KBM\\Ouaknine and Worrell - 2008 - Some Recent Results in Metric Temporal Logic.pdf}
}

@online{PropertyPatternMappings,
  title = {Property {{Pattern Mappings}} for {{LTL}}},
  url = {https://people.cs.ksu.edu/~dwyer/SPAT/ltl.html},
  urldate = {2022-07-23},
  file = {C\:\\Users\\User\\Zotero\\storage\\KECSZXKV\\ltl.html}
}

@online{RateGroupsTimeliness,
  title = {Rate {{Groups}} and {{Timeliness}}},
  url = {https://nasa.github.io/fprime/UsersGuide/best/rate-group.html},
  urldate = {2022-09-05},
  abstract = {Flight Software \& Embedded Systems Framework},
  langid = {american},
  organization = {{F´}},
  file = {C\:\\Users\\User\\Zotero\\storage\\L3BC7IR5\\rate-group.html}
}

@inproceedings{rozierEvaluationComparisonRuntime,
  title = {On the {{Evaluation}} and {{Comparison}} of {{Runtime Verification Tools}} for {{Hardware}} and {{Cyber-Physical Systems}}},
  author = {Rozier, Kristin Yvonne},
  pages = {123--107},
  doi = {10.29007/pld3},
  url = {https://easychair.org/publications/paper/877G},
  urldate = {2022-07-24},
  abstract = {The need for runtime verification (RV), and tools that enable RV in practice, is widely recognized. Systems that need to operate autonomously necessitate on-board RV technologies, from Mars rovers that need to sustain operation despite delayed communication from operators on Earth, to Unmanned Aerial Systems (UAS) that must fly without a human on-board, to robots operating in dynamic or hazardous environments that must take care to preserve both themselves and their surroundings. Enabling all forms of autonomy, from tele-operation to automated control to decision-making to learning, requires some ability for the autonomous system to reason about itself. The broader class of safety-critical systems require means of runtime self-checking to ensure their critical functions have not degraded during use.},
  eventtitle = {{{RV-CuBES}} 2017. {{An International Workshop}} on {{Competitions}}, {{Usability}}, {{Benchmarks}}, {{Evaluation}}, and {{Standardisation}} for {{Runtime Verification Tools}}},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\4H55DGV7\\Rozier - On the Evaluation and Comparison of Runtime Verifi.pdf}
}

@online{RyeFormatReelay,
  title = {Rye {{Format}} - {{Reelay}}},
  url = {https://doganulus.github.io/reelay/rye/},
  urldate = {2022-07-29},
  file = {C\:\\Users\\User\\Zotero\\storage\\NRD5Q8UZ\\rye.html}
}

@incollection{schumannRuntimeAnalysisR2U22016,
  title = {Runtime {{Analysis}} with {{R2U2}}: {{A Tool Exhibition Report}}},
  shorttitle = {Runtime {{Analysis}} with {{R2U2}}},
  booktitle = {Runtime {{Verification}}},
  author = {Schumann, Johann and Moosbrugger, Patrick and Rozier, Kristin Y.},
  editor = {Falcone, Yliès and Sánchez, César},
  date = {2016},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {10012},
  pages = {504--509},
  publisher = {{Springer International Publishing}},
  location = {{Cham}},
  doi = {10.1007/978-3-319-46982-9_35},
  url = {http://link.springer.com/10.1007/978-3-319-46982-9_35},
  urldate = {2022-07-24},
  abstract = {We present R2U2 (Realizable, Responsive, Unobtrusive Unit), a hardware-supported tool and framework for the continuous monitoring of safety-critical and embedded cyber-physical systems. With the widespread advent of autonomous systems such as Unmanned Aerial Systems (UAS), satellites, rovers, and cars, real-time, on-board decision making requires unobtrusive monitoring of properties for safety, performance, security, and system health. R2U2 models combine past-time and future-time Metric Temporal Logic, “mission time” Linear Temporal Logic, probabilistic reasoning with Bayesian Networks, and model-based prognostics.},
  isbn = {978-3-319-46981-2 978-3-319-46982-9},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\33AMF6SA\\Schumann et al. - 2016 - Runtime Analysis with R2U2 A Tool Exhibition Repo.pdf}
}

@article{shawWhatMakesGood,
  title = {What {{Makes Good Research}} in {{Software Engineering}}?},
  author = {Shaw, Mary},
  pages = {10},
  abstract = {Physics, biology, and medicine have well-refined public explanations of their research processes. Even in simplified form, these provide guidance about what counts as "good research" both inside and outside the field. Software engineering has not yet explicitly identified and explained either our research processes or the ways we recognize excellent work.},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\XC9ZNG8Z\\Shaw - What Makes Good Research in Software Engineering.pdf}
}

@online{SimulinkSimulationModelBased,
  title = {Simulink - {{Simulation}} and {{Model-Based Design}}},
  url = {https://www.mathworks.com/products/simulink.html},
  urldate = {2022-07-28},
  abstract = {Simulink is a block diagram environment for Model-Based Design. It supports simulation, automatic code generation, and continuous testing of embedded systems.},
  langid = {english}
}

@online{SpinFormalVerification,
  title = {Spin - {{Formal Verification}}},
  url = {https://spinroot.com/spin/whatispin.html},
  urldate = {2022-08-01},
  file = {C\:\\Users\\User\\Zotero\\storage\\U397PZNP\\whatispin.html}
}

@online{TemporalBehaviorsReelay,
  title = {Temporal {{Behaviors}} - {{Reelay}}},
  url = {https://doganulus.github.io/reelay/behaviors/},
  urldate = {2022-09-06},
  file = {C\:\\Users\\User\\Zotero\\storage\\RE95CF42\\behaviors.html}
}

@misc{ulusOnlineMonitoringMetric2019,
  title = {Online {{Monitoring}} of {{Metric Temporal Logic}} Using {{Sequential Networks}}},
  author = {Ulus, Dogan},
  date = {2019-01-01},
  number = {arXiv:1901.00175},
  eprint = {1901.00175},
  eprinttype = {arxiv},
  primaryclass = {cs},
  publisher = {{arXiv}},
  url = {http://arxiv.org/abs/1901.00175},
  urldate = {2022-07-23},
  abstract = {Metric Temporal Logic (MTL) is a popular formalism to specify patterns with timing constraints over the behavior of cyber-physical systems. In this paper, I propose sequential networks for online monitoring applications and construct network-based monitors from the past fragment of MTL over discrete and dense time behaviors. This class of monitors is more compositional, extensible, and easily implementable than other monitors based on rewriting and automata. I first explain the sequential network construction over discrete time behaviors and then extend it towards dense time by adopting a point-free approach. The formulation for dense time behaviors and MTL radically differs from the traditional pointy definitions and in return, we avoid some longstanding complications. I argue that the point-free approach is more natural and practical therefore should be preferred for the dense time. Finally, I present my implementation together with some experimental results that show the performance of the network-based monitors compared to similar existing tools.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Formal Languages and Automata Theory,Computer Science - Logic in Computer Science},
  file = {C\:\\Users\\User\\Zotero\\storage\\L9RVU955\\Ulus - 2019 - Online Monitoring of Metric Temporal Logic using S.pdf;C\:\\Users\\User\\Zotero\\storage\\ZMVTEETU\\1901.html}
}

@article{villelaThousandthCubeSatStatistical2019,
  title = {Towards the {{Thousandth CubeSat}}: {{A Statistical Overview}}},
  shorttitle = {Towards the {{Thousandth CubeSat}}},
  author = {Villela, Thyrso and Costa, Cesar A. and Brandão, Alessandra M. and Bueno, Fernando T. and Leonardi, Rodrigo},
  date = {2019-01-10},
  journaltitle = {International Journal of Aerospace Engineering},
  shortjournal = {International Journal of Aerospace Engineering},
  volume = {2019},
  pages = {1--13},
  issn = {1687-5966, 1687-5974},
  doi = {10.1155/2019/5063145},
  url = {https://www.hindawi.com/journals/ijae/2019/5063145/},
  urldate = {2022-08-05},
  abstract = {CubeSats have become an interesting innovation in the space sector. Such platforms are being used for several space applications, such as education, Earth remote sensing, science, and defense. As of May 31st, 2018, 855 CubeSats had been launched. Remote sensing application is the main sector in which CubeSats are being used, corresponding to about 45\% of all applications. This fact indicates the commercial potential of such a platform. Fifty eight countries have already been involved with developing CubeSats. The most used CubeSat configuration is 3U (about 64\%), followed by 1U (18\%), while 6U platforms account for about 4\%. In this paper, we present an analysis of the current situation regarding CubeSats worldwide, through the use of a dataset built to encompass information about these satellites. The overall success rate of the CubeSat missions is increasing over time. Moreover, considering CubeSat missions as a Bernoulli experiment, and excluding launch failures, the current success rate was estimated, as a parameter of a binomial distribution, to be about 75\%. By using a logistic model and considering that the launchings keep following the current tendency, one can expect that one thousand CubeSats will be launched in 2021, within 95\% certainty.},
  langid = {english},
  file = {C\:\\Users\\User\\Zotero\\storage\\3KXM5W8X\\Villela et al. - 2019 - Towards the Thousandth CubeSat A Statistical Over.pdf}
}


